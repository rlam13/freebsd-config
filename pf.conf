ext_if = "em0"
lo_if = "lo0"

broken="224.0.0.22 127.0.0.0/8, 172.16.0.0/12, \
        10.0.0.0/8, 169.254.0.0/16, 192.0.2.0/24, \
        192.0.2.0/24, 198.51.100.0/24, 203.0.113.0/24, \
        169.254.0.0/16, 0.0.0.0/8, 240.0.0.0/4, 255.255.255.255/32"
tcp_services = "{ssh, https}"

# If you block all ICMP requests you will break things like path MTU
# discovery. These macros define allowed ICMP types. The additional
# ICMPv6 types are for neighbor discovery (RFC 4861)
icmp_types = "{echoreq, unreach}"
icmp6_types="{echoreq, unreach, 133, 134, 135, 136, 137}"

# Don't send rejections. Just drop.
set block-policy drop

# Exempt the loopback interface to prevent services utilizing the
# local loop from being blocked accidentally.
set skip on $lo_if

# all incoming traffic on external interface is normalized and fragmented
# packets are reassembled.
scrub in on $ext_if all fragment reassemble
#match in all scrub (no-df max-mss random-id 1440)

# Enable antispoofing on the local and external interface
antispoof quick for $lo_if
antispoof quick for $ext_if 


block in log all 
block return out quick inet6 all
block in quick inet6 all

# block packets that fail reverse path check (urpf-failed
# block packets with no route
# block reserved address, except 192.168.x.x (see table above)
# block broadcast address too, within table above
block in quick from { $broken urpf-failed no-route } to any


pass out quick on $ext_if inet keep state

# Allow ICMP
pass inet proto icmp all icmp-type $icmp_types keep state
pass inet6 proto icmp6 all icmp6-type $icmp6_types keep state
